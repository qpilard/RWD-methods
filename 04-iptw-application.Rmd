# Propensity score methods {#iptw-application}

## Background

The **Propensity Score** (PS) is used to replicate the randomization process, aiming to balance individual characteristics at the beginning of a study. Statistically, the PS is defined as the conditional probability of receiving the exposure of interest based on observed baseline characteristics. It is commonly estimated using multivariable logistic regression, where the exposure serves as the dependent variable and the baseline characteristics act as independent variables.

Once the PS is calculated, it can be utilized in various approaches, including matching, stratification, **Inverse Probability of Treatment Weighting** (IPTW), and covariate adjustment.

The ITT analysis described in the \@ref(specify-the-target-trial) will be applied to illustrate the application of IPTW.

## Identify confounders

Observed baseline characteristics incorporated in the logistic regression must be defined as **confounder**s, which are **variables that affect both treatment assignment and the outcome** without being part of the causal pathway between them. Other variable types, such as mediators or colliders, may also be present; however, adjusting for these can introduce bias.

We recommend using Directed Acyclic Graphs (DAGs) to visually represent causal relationships, and communicate with clinical experts. DAGs can be created using the DAGitty website or dagitty R package.

In our example, we identified age at diagnosis, gender, Beck score and socioeconomic status as potential confounders of the association between treatment exposure and relapse.

## IPTW implementation

```{r package2, include=FALSE, message=FALSE}
#Install and load packages
ipak <- function(pkg){
  new.pkg <- pkg[!(pkg %in% installed.packages()[, "Package"])]
  if (length(new.pkg)) 
    install.packages(new.pkg, dependencies = TRUE, repos = "https://cloud.r-project.org")
  sapply(pkg, require, character.only = TRUE)
}
list.of.packages <- c("cobalt",
                      "WeightIt",
                      "gtsummary",
                      "smd",
                      "survey",
                      "ggplot2",
                      "ggpubr",
                      "survminer")
ipak(list.of.packages)
```

```{r simulation2, include=FALSE}
set.seed(42)  # Ensure reproducibility

# Number of patients
N <- 600

# Patient IDs
ID <- 1:N

# Generation of base variables
AGE <- pmax(pmin(round(rnorm(N, mean = 32, sd = 6.19)), 80), 18)
GENDER <- sample(0:1, N, replace = TRUE)
SOCIO_ECO <- sample(1:5, N, replace = TRUE)
SOCIO_ECO_2 <- as.numeric(SOCIO_ECO == 2)
SOCIO_ECO_3 <- as.numeric(SOCIO_ECO == 3)
SOCIO_ECO_4 <- as.numeric(SOCIO_ECO == 4)
SOCIO_ECO_5 <- as.numeric(SOCIO_ECO == 5)

# Generation of BECK score at diagnosis (BECK0)
BECK0 <- pmax(pmin(round(rnorm(N, mean = 30, sd = 9.33)), 63), 0)

# Utility function to generate binary variables based on a logistic model
logit_prob <- function(eta) {
  1 / (1 + exp(-eta))
}

# Coefficients for predictors
coefficients <- list(
  intercept = -5,      
  age = -0.04,          
  gender = -0.3,        
  beck0 = 0.2,         
  socio_eco_2 = -0.2,
  socio_eco_3 = -0.1,
  socio_eco_4 = 0.1,
  socio_eco_5 = 0.3
)

# Generation of initial treatment (TREAT0)
eta_treat0 <- coefficients$intercept + 
  coefficients$age * AGE + 
  coefficients$gender * GENDER +
  coefficients$beck0 * BECK0 + 
  coefficients$socio_eco_2 * SOCIO_ECO_2 +
  coefficients$socio_eco_3 * SOCIO_ECO_3 + 
  coefficients$socio_eco_4 * SOCIO_ECO_4 +
  coefficients$socio_eco_5 * SOCIO_ECO_5

TREAT0 <- rbinom(N, 1, logit_prob(eta_treat0 + rnorm(N)))

# Generation of BECK score after six weeks (BECK6)
coefficients <- list(
  intercept = -7,          
  age = -0.05,             
  gender = -0.1,           
  socio_eco_2 = -0.2,      
  socio_eco_3 = -0.1,      
  socio_eco_4 = 0.1,       
  socio_eco_5 = 0.3,       
  beck0 = 0.25,            
  treat0 = -3              
)

eta_beck6 <- coefficients$intercept + 
  coefficients$age * AGE +
  coefficients$gender * GENDER +
  coefficients$socio_eco_2 * SOCIO_ECO_2 +
  coefficients$socio_eco_3 * SOCIO_ECO_3 + 
  coefficients$socio_eco_4 * SOCIO_ECO_4 +
  coefficients$socio_eco_5 * SOCIO_ECO_5 +
  coefficients$beck0 * BECK0 +
  coefficients$treat0 * TREAT0

BECK6 <- pmax(pmin(round(rnorm(N, mean = BECK0 + eta_beck6 + rnorm(N), sd = 9.33)), 63), 0)

# Generation of change indicator (CHANGE_BECK) and switch at 6 weeks (SWITCH)
CLINICAL_CHANGE_BECK <- ifelse(((BECK6 - BECK0)/(BECK0)*100) > -20, 1, 0)

# Generation of the switch variable with condition
coefficients <- list(
  intercept = -3,              
  age = -0.01,                 
  gender = -0.05,              
  socio_eco_2 = -0.05,         
  socio_eco_3 = -0.02,         
  socio_eco_4 = 0.02,          
  socio_eco_5 = 0.05,          
  treat0 = -0.5,               
  clinical_change_beck = 2     
)

# Define eta_switch based on achieving the clinical change
eta_switch <- coefficients$intercept + 
  coefficients$age * AGE + 
  coefficients$gender * GENDER +
  coefficients$treat0 * TREAT0 + 
  coefficients$clinical_change_beck * (1 - CLINICAL_CHANGE_BECK) + 
  coefficients$socio_eco_2 * SOCIO_ECO_2 +
  coefficients$socio_eco_3 * SOCIO_ECO_3 + 
  coefficients$socio_eco_4 * SOCIO_ECO_4 +
  coefficients$socio_eco_5 * SOCIO_ECO_5 +
  rnorm(N)

# Generate the switch variable ensuring it cannot switch before week 6
SWITCH <- ifelse(CLINICAL_CHANGE_BECK == 1, rbinom(N, 1, logit_prob(eta_switch)), 0)

# Generation of relapse (EVENT) and time until relapse (TIME_TO_EVENT)
base_hazard <- 0.0005
EVENT <- numeric(N)
TIME_TO_EVENT <- numeric(N)
max_follow_up <- 52  # Maximum follow-up duration in weeks

coefficients <- list(
  intercept = -4,                 
  age = 0.01,                     
  gender = 0.1,                   
  socio_eco_2 = 0.05,             
  socio_eco_3 = 0.02,             
  socio_eco_4 = -0.03,            
  socio_eco_5 = -0.08,            
  beck0 = 0.2,                    
  treat0 = -0.5,                  
  clinical_change_beck = -1.5,    
  switch = 0.3                    
)

for (i in 1:N) {
  eta_event <- coefficients$intercept + 
    coefficients$age * AGE[i] + 
    coefficients$gender * GENDER[i] +
    coefficients$beck0 * BECK0[i] + 
    coefficients$socio_eco_2 * SOCIO_ECO_2[i] +
    coefficients$socio_eco_3 * SOCIO_ECO_3[i] + 
    coefficients$socio_eco_4 * SOCIO_ECO_4[i] +
    coefficients$socio_eco_5 * SOCIO_ECO_5[i] + 
    coefficients$treat0 * TREAT0[i] +
    coefficients$clinical_change_beck * CLINICAL_CHANGE_BECK[i] + 
    coefficients$switch * SWITCH[i] + rnorm(1)
  
  adjusted_hazard <- base_hazard * exp(eta_event)
  
  # Generate time to event after week 6
  TIME_TO_EVENT[i] <- ifelse(SWITCH[i] == 1, 
                             round(rexp(1, rate = adjusted_hazard), 0) + 6, 
                             round(rexp(1, rate = adjusted_hazard), 0) + 1)
  
  # Ensure EVENT only occurs after week 6
  EVENT[i] <- as.integer(TIME_TO_EVENT[i] <= max_follow_up & TIME_TO_EVENT[i] > 6)
  
  # Set TIME_TO_EVENT to max_follow_up if EVENT does not occur
  TIME_TO_EVENT[i] <- ifelse(EVENT[i] == 1, TIME_TO_EVENT[i], max_follow_up)
}

# Censoring management
censoring_rate <- 0.05  # Censoring rate
CENSORING_TIME <- round(rexp(N, rate = -log(1 - censoring_rate)), 0) + 1  # Censoring time
CENSORING_TIME[CENSORING_TIME > max_follow_up] <- max_follow_up  # Limit to maximum

# Adjust TIME_TO_EVENT based on censored data
TIME_TO_EVENT <- pmin(TIME_TO_EVENT, CENSORING_TIME)

# Verify that SWITCH is consistent with TIME_TO_EVENT
TIME_TO_EVENT <- ifelse(SWITCH == 1 & TIME_TO_EVENT < 6, TIME_TO_EVENT + 6, TIME_TO_EVENT)

# Organize data in a data frame
data <- data.frame(ID, AGE, GENDER, SOCIO_ECO, BECK0, BECK6, TREAT0, SWITCH, EVENT, TIME_TO_EVENT)

data$GENDER <- as.factor(data$GENDER)
data$SOCIO_ECO <- as.factor(data$SOCIO_ECO)
data$TREAT0 <- as.factor(data$TREAT0)
data$SWITCH <- as.factor(data$SWITCH)
```

This code implements the IPTW approach using the Average Treatment Effect (ATE) estimand:

```{r iptw, message=FALSE}
library(WeightIt)
library(gtsummary)
library(survey)
library(dplyr)
library(ggpubr)

#Perform weighting
W <- weightit(TREAT0 ~ AGE + GENDER + SOCIO_ECO + BECK0,
                            data = data,
                            method = "glm",
                            estimand = "ATE")

data$weights <- W$weights
data$ps <- W$ps
```

## Balance Diagnostics

To evaluate balance after weighting, visual assessment is usually done. First, PS distributions are represented to assess the degree of overlap between the Setralex and Duloxyn individuals The objective is to have a large enough common support to ensure that it exists a population in-between these two.

```{r ps}
#Display PS
plot1<-ggplot2::ggplot(data, mapping = aes(x = ps))+
  ggplot2::geom_density(colour="red")+
  ggplot2::geom_density(mapping=aes(group = TREAT0, fill = TREAT0),alpha=0.4)+
  ggtitle("Unweighted")+
  scale_fill_manual(name="Treatment",labels=c("Sertralex","Duloxyn"),values=c("#FFDB6D","#00AFBB"))+
  xlab("Propensity Score (PS)")+
  ylab("Density")+
  xlim(0,1)+
  labs(caption="")+
  theme_minimal()
  
#After weighting
plot2<-ggplot2::ggplot(data, mapping = aes(x = ps, weight = weights))+
  ggplot2::geom_density(colour="red")+
  ggplot2::geom_density(mapping=aes(group = TREAT0, fill = TREAT0),alpha=0.4)+
  ggtitle("Weighted")+
  scale_fill_manual(name="Treatment",labels=c("Sertralex","Duloxyn"),values=c("#FFDB6D","#00AFBB"))+
  xlab("Propensity Score (PS)")+
  ylab("Density")+
  xlim(0,1)+
  labs(caption="*the red line indicates the PS distribution for the overall population")+
  theme_minimal()
  
ggarrange(plot1,plot2,common.legend = T)
```

We observed that after weighting the two distributions curves overlaid and therefore this indicates that the dataset is correctly balance in average. Then, we usually assess balance for each variable.

```{r love_plot}
love.plot(W, 
          binary = "std", 
          thresholds = c(m = .1),
          sample.names = c("Before weighting", "After weighting"))
```

We observe that after weighting the BECK score remains above the recommended threeshold. That is why, we suggest adjusting on it (i.e. doubly robust approach) when the outcome is investigated.

A summary descriptive table before and after weighting is represented below stratifed on treatment status.

```{r table_weighting, warning=FALSE}
#Before weighting
t1 <- data %>%
  select(AGE, GENDER, SOCIO_ECO, BECK0, TREAT0) %>%
  tbl_summary(by = TREAT0, 
              statistic = list(all_continuous() ~ "{mean} ({sd})"),
              label = list(AGE ~ "Age (at diagnosis)",
                           GENDER ~ "Gender",
                           SOCIO_ECO ~ "Socioeconomic status (1-5)",
                           BECK0 ~ "Beck score (0-63)")) %>%
  add_difference(test = everything() ~ "smd") %>%
  add_overall() %>%
  modify_header(label ~ "**Variable**", 
                estimate ~ "**SMD**", 
                stat_0 ~ "**Total**", 
                stat_1 ~ "**Sertralex**", 
                stat_2 ~ "**Duloxyn**")

data_selected <- data %>%
  select(AGE, GENDER, SOCIO_ECO, BECK0, TREAT0)

#After weighting
data_svy <- svydesign(ids = ~1, data = data_selected, weights = ~W$weights)
t2 <- data_svy %>%
  tbl_svysummary(by = TREAT0, 
                 statistic = list(all_continuous() ~ "{mean} ({sd})"),
                 label = list(AGE ~ "Age (at diagnosis)",
                           GENDER ~ "Gender",
                           SOCIO_ECO ~ "Socioeconomic status (1-5)",
                           BECK0 ~ "Beck score (0-63)")) %>%
  add_difference(test = everything() ~ "smd") %>%
  add_overall() %>% 
  modify_header(label ~ "**Variable**", 
                estimate ~ "**SMD**", 
                stat_0 ~ "**Total**",
                stat_1 ~ "**Sertralex**",
                stat_2 ~ "**Duloxyn**")

for (int_col in c("modify_stat_N", "modify_stat_n")) {
  t1$table_styling$header[[int_col]] <-
    t1$table_styling$header[[int_col]] |> as.numeric()
}

tbl_merge(tbls = list(t1, t2),
          tab_spanner = c(
            paste0("**Unweighted (N=",nrow(data),")**"), 
            paste0("**Weighted (ESS=",round(ESS(W$weights),0),")**")
            )
          )%>%
  modify_table_body(~ .x %>% select(-conf.low_1, -conf.low_2))
```

## Outcome analysis

We compare below the unweighted and weighted Kaplan-Meir curves stratified on treatment group.

```{r km, warning=FALSE}
library(survminer)
unadjusted<- survfit(Surv(TIME_TO_EVENT, EVENT)~TREAT0, data = data)
adjusted<- survfit(Surv(TIME_TO_EVENT, EVENT)~TREAT0, data = data, weights = weights)
fit<-list(unadjusted,adjusted)
ggsurvplot_combine(fit, 
                   data = data,
                   legend.title = "",
                   legend.labs = c("Unweighted: Sertralex", 
                                   "Unweighted: Duloxyn",
                                   "Weighted: Sertralex", 
                                   "Weighted: Duloxyn"),
                   palette = c("#ff331a","#ff80a6","#FFDB6D","#27d4ad"),
                   conf.int = TRUE,
                   xlab = "Time (in weeks)",
                   ggtheme = theme_bw())
```

Then, we implement Cox models

```{r cox}
unweighted <- coxph(Surv(TIME_TO_EVENT, EVENT)~TREAT0, data = data) %>%
  tbl_regression(
    exponentiate = TRUE,
    label = list(TREAT0 ~ "Treatment (unweighted)"))
weighted <- coxph(Surv(TIME_TO_EVENT, EVENT)~TREAT0+BECK0, weights = weights, data = data)  %>%
  tbl_regression(
    exponentiate = TRUE,
    label = list(TREAT0 ~ "Treatment (weighted)",
                 BECK0 ~ "Beck (to adjust remaining imbalance)"))
tbl_stack(list(unweighted, weighted))
```
